VERSIONS
--------
v0.1.10-b8 - Wrote test_proxy_descriptors, simplified proxy_descriptors
             as a result. 100% coverage of proxy_descriptors.py.
             Doctests for get_args_pos in helpers.py, 100% coverage.
             test_deco_settings.py: 100% coverage of deco_settings.py.
             TODO  test_log_calls.py,
             todo  documentation (log_calls.md, readme.md)

v0.1.10-b7 - Reworked __call__ routine to better use inspect module's
             introspection, specifically the bind method. Defaulted
             arg values weren't working quite right.
             Implemented stats.call_history_as_csv, made the fn name
             field in CallRecord the prefixed function name, and added
             a caller_chain field to CallRecord.
             Descriptors on stats object:
                num_calls_total, num_calls_logged, call_history,
                call_history_as_csv, total_elapsed, clear_history (method)
            Need more tests, even more than before.

v0.1.10-b6 - New: stats object available on the deco'd function,
             with attributes num_calls, time_elapsed, call_history.
             Four new keyword parameters:
                log_elapsed, log_call_number, record_history, max_history
             Nice lil class ClassInstanceAttrProxy (stats is one of them).
             All tests from v0.1.10-b5 pass, but we still need more tests,
             and documentation -- now, even more of both than at v0.1.10-b5.

v0.1.10-b5 - Base class for log_calls that does count logging?
             Possible to Hide some of the housekeeping obligations?
             call __call__ and bump counters? Arrogate 'enabled' keyword
             shared by all decos, let's say, every one with this base class.
             or _blah_enabled? For now, no.

             Realization that (the hideously named) DecoSettingsMapping is a mechanism
             for letting multiple decorators each share their own namespaces,
             e.g. imagine a log_num_calls deco... or add functionality to base class
             AND/OR imagine letting subclass of DecoSettingsMapping override
             make_setting_descriptor (made that a class method). Let caller (subclass?) provide
             additional keywords to be attrs of the __Mapping object
                e.g. num_calls
                    num_logged_calls
                    num_unlogged_calls
             or decofn.deco_settings['log_calls'].my_attribute
             where decofn.deco_settings['log_calls'].my_attribute is a descriptor
             provided by subclass, and so it can access attrs of "instance"
             i.e. the __Mapping it's bound to.

v0.1.10-b4 - Implement attributes i.e. descriptors on DecoSettingsMapping
             for each setting (e.g. f.log_calls_settings.enabled, you can
             get and set it, i.e. __get__ and __set__ it. Thus,
                    print('d.log_retval =', d.log_retval)
                    d.enabled = 17
                    d.log_retval = False
                    d.log_exit = True
                    d.log_args = 'different_log_args_kwd='
             etc.

v0.1.10-b3 - New feature: mapping interface for settings! Any log_calls-deco'd
             function f now has an attribute .log_calls_settings which behaves
             "just like" a dictionary - __?etitem__, update, __contains__,
             __len__, iteration through names, iteration through .items(),
             a real __repr__ fn, a real __str__ fn.
             Users can get & set the settings of a deco'd function much more
             easily using these interfaces/methods,  no intrusion on deco'd
             function's signature.
             Indirect values still have their place, for controlling an entire
             call subtree/subgraph.
v0.1.10-b2 - Reworked decorator parameter handling: now every parameter except
             prefix can take either direct or indirect values, indirect values
             being names of keyword parameters/arguments of the wrapped function.
             Thus, no more *_kwd parameters (3 fewer). prefix can't be late-bound
             because it's needed immediately, as soon as the wrapped function
             is returned by __call__.
             Updated the doc/tests test_log_calls.py to reflect these changes,
             plus probably other little improvements.

v0.1.10-b1 - Added examples/doctests "Enabling with ints rather than booleans".
             doctests moved to tests/test_log_calls.py. VERSIONS moved to
             CHANGES.txt (this file).
v0.1.9    -- reworked logic of enabled, enabled_kwd parameters:
             enabled_kwd always overrides enabled.
             Fixed: if a wrapped function explicitly declares its enabled_kwd
             parameter, its default value wasn't being used when a caller
             didn't explicitly pass a value for the keyword parameter.
v0.1.8    -- another example: dynamically enabling logging.
v0.1.7    -- actual doc (prose) in the docstrings.
v0.1.6    -- illustrative code converted to doctests;
             metaclass and multi-handler logging examples/tests;
             log_calls is now a package;
             export difference_update.
v0.1.5    -- call chains! + illustrative code; 100% coverage.
v0.1.4    -- switched to dedicated 'keyword' params for specifying enabled,
             logger, and (what prompted the change) args_sep:
             this way the top-level caller can compel logged functions
             lower in the call chain to "conform"; exposed a bug (don't
             use deepcopy [can't deepcopy a logger!] use copy), fixed.
             Added example code at end giving 100% coverage.
v0.1.3    -- logger can be a string naming a keyword arg of wrapped function;
             better output when using a logger.
v0.1.2    -- logger, loglevel keyword parameters
v0.1.1    -- removed redundant function-based decos log_caller, log_args,
             don't want to keep them in sync with the superset log_calls.
